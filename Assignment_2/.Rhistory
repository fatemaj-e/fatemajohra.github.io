# Setting the parameter (3 rows by 2 cols)
par(mfrow=c(1, 1))
# Scatterplot
x <- mtcars$wt
y1 <- mtcars$mpg
y2 <- mtcars$hp / 50   # scaled horsepower
# Set label orientation, margins, text size
par(las=1, mar=c(4, 4, 2, 4), cex=1)
# Start new plot
plot.new()
plot.window(range(x), range(c(y1, y2)))  # set x and y limits based on both series
# Add lines
lines(x, y1, col="dodgerblue", lwd=2)
lines(x, y2, col="darkorange", lwd=2)
# Add points
points(x, y1, pch=17, cex=1.5, col="dodgerblue")
points(x, y2, pch=21, bg="orange", cex=2, col="darkorange")
# Customize axes
par(col="gray50", fg="gray50", col.axis="gray50")
axis(1, at=seq(floor(min(x)), ceiling(max(x)), 1))  # bottom x-axis
axis(2, at=seq(floor(min(y1)), ceiling(max(y1)), 5)) # left y-axis
axis(4, at=seq(floor(min(y2)), ceiling(max(y2)), 1)) # right y-axis
box(bty="u")
# Add axis labels
mtext("Car Weight (1000 lbs)", side=1, line=2, cex=0.8)
mtext("MPG (Left Axis)", side=2, line=2, las=0, cex=0.8)
mtext("HP / 50 (Right Axis)", side=4, line=2, las=0, cex=0.8)
# Add text annotation
text(4, max(y1)-1, "Car", col="darkgreen")
# Reset par colors
par(mar=c(5.1, 4.1, 4.1, 2.1), col="black", fg="black", col.axis="black")
# Histogram
Y <- mtcars$mpg
Y[Y < 10 | Y > 35] <- NA  # trim range
x <- seq(10, 35, .5)
par(mar=c(4.5, 4.1, 3.1, 0))
hist(Y, breaks=10, ylim=c(0, 0.2),
col="gray80", freq=FALSE,
main="Histogram of MPG")
lines(density(na.omit(Y)), lwd=2)
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Barplot
# Aggregate mtcars: rows = cylinders, columns = number of carburetors
carb_cyl <- table(mtcars$cyl, mtcars$carb)  # rows = cyl, columns = carb
# Set margins
par(mar=c(2, 3.1, 2, 2.1))
# Bar plot with grayscale colors
midpts <- barplot(carb_cyl, col=gray(0.1 + seq(1, nrow(carb_cyl)*2-1, 2)/11),
names=rep("", ncol(carb_cyl)))
# Custom x-axis labels with newline (if needed)
mtext(sub(" ", "\n", colnames(carb_cyl)), at=midpts, side=1, line=0.5, cex=0.5)
# Add text labels inside bars
text(rep(midpts, each=nrow(carb_cyl)),
apply(carb_cyl, 2, cumsum) - carb_cyl/2,
carb_cyl,
col=rep(c("white", "black", "gray40"), length.out=nrow(carb_cyl)*ncol(carb_cyl)),
cex=0.8)
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Axis label
mtext("Number of Cylinders", side=1, line=2.5, cex=0.8)
# Add Manual cars (am == 1)
boxplot(mpg ~ cyl, data = mtcars,
add = TRUE, boxwex = 0.25, at = sort(unique(mtcars$cyl)) + 0.2,
subset = am == 1, col="gray")
# Legend
legend("topright", c("Automatic", "Manual"),
fill = c("white", "gray"), bty="n")
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Boxplot
# Set margins
par(mar=c(3, 4.1, 2, 0))
# Side-by-side boxplots: Automatic cars (am == 0)
boxplot(mpg ~ cyl, data = mtcars,
boxwex = 0.25, at = sort(unique(mtcars$cyl)) - 0.2,
subset = am == 0, col="white",
xlab="", ylab="MPG", ylim=c(min(mtcars$mpg), max(mtcars$mpg)))
# Axis label
mtext("Number of Cylinders", side=1, line=2.5, cex=0.8)
# Add Manual cars (am == 1)
boxplot(mpg ~ cyl, data = mtcars,
add = TRUE, boxwex = 0.25, at = sort(unique(mtcars$cyl)) + 0.2,
subset = am == 1, col="gray")
# Legend
legend("topright", c("Automatic", "Manual"),
fill = c("white", "gray"), bty="n")
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Barplot
# Aggregate mtcars: rows = cylinders, columns = number of carburetors
carb_cyl <- table(mtcars$cyl, mtcars$carb)  # rows = cyl, columns = carb
# Set margins
par(mar=c(2, 3.1, 2, 2.1))
# Bar plot with grayscale colors
midpts <- barplot(carb_cyl, col=gray(0.1 + seq(1, nrow(carb_cyl)*2-1, 2)/11),
names=rep("", ncol(carb_cyl)))
# Custom x-axis labels with newline (if needed)
mtext(sub(" ", "\n", colnames(carb_cyl)), at=midpts, side=1, line=0.5, cex=0.5)
# Add text labels inside bars
text(rep(midpts, each=nrow(carb_cyl)),
apply(carb_cyl, 2, cumsum) - carb_cyl/2,
carb_cyl,
col=rep(c("white", "black", "gray40"), length.out=nrow(carb_cyl)*ncol(carb_cyl)),
cex=0.8)
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Boxplot
# Set margins
par(mar=c(3, 4.1, 2, 0))
# Side-by-side boxplots: Automatic cars (am == 0)
boxplot(mpg ~ cyl, data = mtcars,
boxwex = 0.25, at = sort(unique(mtcars$cyl)) - 0.2,
subset = am == 0, col="white",
xlab="", ylab="MPG", ylim=c(min(mtcars$mpg), max(mtcars$mpg)))
# Axis label
mtext("Number of Cylinders", side=1, line=2.5, cex=0.8)
# Add Manual cars (am == 1)
boxplot(mpg ~ cyl, data = mtcars,
add = TRUE, boxwex = 0.25, at = sort(unique(mtcars$cyl)) + 0.2,
subset = am == 1, col="gray")
# Legend
legend("topright", c("Automatic", "Manual"),
fill = c("white", "gray"), bty="n")
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Use volcano as the data
z <- volcano
z[is.na(z)] <- 1  # keep this step, same as prof
# Keep margins and line width exactly as professor
par(mar=c(0, 0.5, 0, 0), lwd=0.5)
# Persp plot (everything else same as prof)
persp(1:nrow(z), 1:ncol(z), z, theta = 30, phi = 30,
expand = 0.5)
# Reset margins and line width
par(mar=c(5.1, 4.1, 4.1, 2.1), lwd=1)
par(mar=c(0, 2, 1, 2), xpd=FALSE, cex=0.5)
# Dataset: counts of cars by gears
pie.sales <- table(mtcars$gear)
names(pie.sales) <- paste(names(pie.sales), "gear")
# Keep grayscale and all other settings same
pie(pie.sales, col = gray(seq(0.3,1.0,length=length(pie.sales))))
### Individual plots using mtcars dataset
### Paul Murrell's R examples (selected, adapted to mtcars)
## Start plotting from basics
plot(mtcars$wt, mtcars$mpg, pch=17,
main="Weight vs MPG")  # pch changed
text(4, 30, "Miles per Gallon\nversus\nWeight (1000 lbs)")
head(mtcars)
# --------------------------------------------------------
# Setting the parameter (3 rows by 2 cols)
par(mfrow=c(1, 1))
# Scatterplot
x <- mtcars$wt
y1 <- mtcars$mpg
y2 <- mtcars$hp / 50   # scaled horsepower
# Set label orientation, margins, text size
par(las=1, mar=c(4, 4, 2, 4), cex=1)
# Start new plot
plot.new()
plot.window(range(x), range(c(y1, y2)))  # set x and y limits based on both series
# Add lines
lines(x, y1, col="dodgerblue", lwd=2)
lines(x, y2, col="darkorange", lwd=2)
# Add points
points(x, y1, pch=17, cex=1.5, col="dodgerblue")
points(x, y2, pch=21, bg="orange", cex=2, col="darkorange")
# Customize axes
par(col="gray50", fg="gray50", col.axis="gray50")
axis(1, at=seq(floor(min(x)), ceiling(max(x)), 1))  # bottom x-axis
axis(2, at=seq(floor(min(y1)), ceiling(max(y1)), 5)) # left y-axis
axis(4, at=seq(floor(min(y2)), ceiling(max(y2)), 1)) # right y-axis
box(bty="u")
# Add axis labels
mtext("Car Weight (1000 lbs)", side=1, line=2, cex=0.8)
mtext("MPG (Left Axis)", side=2, line=2, las=0, cex=0.8)
mtext("HP / 50 (Right Axis)", side=4, line=2, las=0, cex=0.8)
# Add text annotation
text(4, max(y1)-1, "Car", col="darkgreen")
# Reset par colors
par(mar=c(5.1, 4.1, 4.1, 2.1), col="black", fg="black", col.axis="black")
# Histogram
Y <- mtcars$mpg
Y[Y < 10 | Y > 35] <- NA  # trim range
x <- seq(10, 35, .5)
par(mar=c(4.5, 4.1, 3.1, 0))
hist(Y, breaks=10, ylim=c(0, 0.2),
col="gray80", freq=FALSE,
main="Histogram of MPG")
lines(density(na.omit(Y)), lwd=2)
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Barplot
# Aggregate mtcars: rows = cylinders, columns = number of carburetors
carb_cyl <- table(mtcars$cyl, mtcars$carb)  # rows = cyl, columns = carb
# Set margins
par(mar=c(2, 3.1, 2, 2.1))
# Bar plot with grayscale colors
midpts <- barplot(carb_cyl, col=gray(0.1 + seq(1, nrow(carb_cyl)*2-1, 2)/11),
names=rep("", ncol(carb_cyl)))
# Custom x-axis labels with newline (if needed)
mtext(sub(" ", "\n", colnames(carb_cyl)), at=midpts, side=1, line=0.5, cex=0.5)
# Add text labels inside bars
text(rep(midpts, each=nrow(carb_cyl)),
apply(carb_cyl, 2, cumsum) - carb_cyl/2,
carb_cyl,
col=rep(c("white", "black", "gray40"), length.out=nrow(carb_cyl)*ncol(carb_cyl)),
cex=0.8)
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Boxplot
# Set margins
par(mar=c(3, 4.1, 2, 0))
# Side-by-side boxplots: Automatic cars (am == 0)
boxplot(mpg ~ cyl, data = mtcars,
boxwex = 0.25, at = sort(unique(mtcars$cyl)) - 0.2,
subset = am == 0, col="white",
xlab="", ylab="MPG", ylim=c(min(mtcars$mpg), max(mtcars$mpg)))
# Axis label
mtext("Number of Cylinders", side=1, line=2.5, cex=0.8)
# Add Manual cars (am == 1)
boxplot(mpg ~ cyl, data = mtcars,
add = TRUE, boxwex = 0.25, at = sort(unique(mtcars$cyl)) + 0.2,
subset = am == 1, col="gray")
# Legend
legend("topright", c("Automatic", "Manual"),
fill = c("white", "gray"), bty="n")
# Reset margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
# Persp
# Use volcano as the data
z <- volcano
z[is.na(z)] <- 1  # keep this step, same as prof
# Keep margins and line width exactly as professor
par(mar=c(0, 0.5, 0, 0), lwd=0.5)
# Persp plot (everything else same as prof)
persp(1:nrow(z), 1:ncol(z), z, theta = 30, phi = 30,
expand = 0.5)
# Reset margins and line width
par(mar=c(5.1, 4.1, 4.1, 2.1), lwd=1)
# Piechart
par(mar=c(0, 2, 1, 2), xpd=FALSE, cex=0.5)
# Dataset: counts of cars by gears
pie.sales <- table(mtcars$gear)
names(pie.sales) <- paste(names(pie.sales), "gear")
# Keep grayscale and all other settings same
pie(pie.sales, col = gray(seq(0.3,1.0,length=length(pie.sales))))
dev.off()
n_samples <- 5000          # Number of MCMC samples (increased from 1000)
p <- numeric(n_samples)    # Vector to store probability samples
p[1] <- 0.5                # Initial guess for probability of water
W <- 6  # Number of water tosses
L <- 3  # Number of land tosses
# ------------------------
# 2. Metropolis Algorithm
# ------------------------
for (i in 2:n_samples) {
# Step 1: Propose new p using normal random walk
p_new <- rnorm(1, mean = p[i-1], sd = 0.1)  # SD modified for smoother sampling
# Step 2: Reflect boundaries to keep p in [0,1]
if (p_new < 0) p_new <- abs(p_new)
if (p_new > 1) p_new <- 2 - p_new
# Step 3: Compute likelihoods for old and new p
q_old <- dbinom(W, size = W + L, prob = p[i-1])
q_new <- dbinom(W, size = W + L, prob = p_new)
# Step 4: Compute acceptance probability and decide whether to accept p_new
accept_prob <- q_new / q_old
if (runif(1) < accept_prob) {
p[i] <- p_new
} else {
p[i] <- p[i-1]
}
}
# ------------------------
# 3. Posterior Plot
# ------------------------
dens(p, xlim = c(0,1), main = "Posterior Distribution of p (Water Probability)")
install.packages("devtools")        # if not already installed
devtools::install_github("rmcelreath/rethinking")  # installs rethinking package
install.packages("devtools")
n_samples <- 5000          # Number of MCMC samples (increased from 1000)
p <- numeric(n_samples)    # Vector to store probability samples
p[1] <- 0.5                # Initial guess for probability of water
W <- 6  # Number of water tosses
L <- 3  # Number of land tosses
# ------------------------
# 2. Metropolis Algorithm
# ------------------------
for (i in 2:n_samples) {
# Step 1: Propose new p using normal random walk
p_new <- rnorm(1, mean = p[i-1], sd = 0.1)  # SD modified for smoother sampling
# Step 2: Reflect boundaries to keep p in [0,1]
if (p_new < 0) p_new <- abs(p_new)
if (p_new > 1) p_new <- 2 - p_new
# Step 3: Compute likelihoods for old and new p
q_old <- dbinom(W, size = W + L, prob = p[i-1])
q_new <- dbinom(W, size = W + L, prob = p_new)
# Step 4: Compute acceptance probability and decide whether to accept p_new
accept_prob <- q_new / q_old
if (runif(1) < accept_prob) {
p[i] <- p_new
} else {
p[i] <- p[i-1]
}
}
# ------------------------
# 3. Posterior Plot
# ------------------------
dens(p, xlim = c(0,1), main = "Posterior Distribution of p (Water Probability)")
n_samples <- 5000          # Number of MCMC samples (increased from 1000)
p <- numeric(n_samples)    # Vector to store probability samples
p[1] <- 0.5                # Initial guess for probability of water
W <- 6  # Number of water tosses
L <- 3  # Number of land tosses
# ------------------------
# 2. Metropolis Algorithm
# ------------------------
for (i in 2:n_samples) {
# Step 1: Propose new p using normal random walk
p_new <- rnorm(1, mean = p[i-1], sd = 0.1)  # SD modified for smoother sampling
# Step 2: Reflect boundaries to keep p in [0,1]
if (p_new < 0) p_new <- abs(p_new)
if (p_new > 1) p_new <- 2 - p_new
# Step 3: Compute likelihoods for old and new p
q_old <- dbinom(W, size = W + L, prob = p[i-1])
q_new <- dbinom(W, size = W + L, prob = p_new)
# Step 4: Compute acceptance probability and decide whether to accept p_new
accept_prob <- q_new / q_old
if (runif(1) < accept_prob) {
p[i] <- p_new
} else {
p[i] <- p[i-1]
}
}
# ------------------------
# 3. Posterior Plot
# Base R density plot for posterior
plot(density(p), xlim = c(0,1),
main = "Posterior Distribution of p (Water Probability)",
xlab = "p", ylab = "Density")
# Overlay analytical Beta posterior
curve(dbeta(x, W + 1, L + 1), lty = 2, add = TRUE, col = "red")
# Add legend
legend("topright", legend = c("MCMC", "Analytical Beta"),
lty = c(1,2), col = c("black","red"))
# ------------------------
# 4. Summary Statistics
# ------------------------
cat("Posterior mean from MCMC:", mean(p), "\n")
cat("Posterior sd from MCMC:", sd(p), "\n")
n_samples <- 5000          # Number of MCMC samples (increased from 1000)
p <- numeric(n_samples)    # Vector to store probability samples
p[1] <- 0.5                # Initial guess for probability of water
W <- 6  # Number of water tosses
L <- 3  # Number of land tosses
# ------------------------
# 2. Metropolis Algorithm
# ------------------------
for (i in 2:n_samples) {
# Step 1: Propose new p using normal random walk
p_new <- rnorm(1, mean = p[i-1], sd = 0.1)  # SD modified for smoother sampling
# Step 2: Reflect boundaries to keep p in [0,1]
if (p_new < 0) p_new <- abs(p_new)
if (p_new > 1) p_new <- 2 - p_new
# Step 3: Compute likelihoods for old and new p
q_old <- dbinom(W, size = W + L, prob = p[i-1])
q_new <- dbinom(W, size = W + L, prob = p_new)
# Step 4: Compute acceptance probability and decide whether to accept p_new
accept_prob <- q_new / q_old
if (runif(1) < accept_prob) {
p[i] <- p_new
} else {
p[i] <- p[i-1]
}
}
# ------------------------
# 3. Posterior Plot
# Base R density plot for posterior
plot(density(p), xlim = c(0,1),
main = "Posterior Distribution of p (Water Probability)",
xlab = "p", ylab = "Density")
# Overlay analytical Beta posterior
curve(dbeta(x, W + 1, L + 1), lty = 2, add = TRUE, col = "red")
# Add legend
legend("topright", legend = c("MCMC", "Analytical Beta"),
lty = c(1,2), col = c("black","red"))
# ------------------------
# 4. Summary Statistics
# ------------------------
cat("Posterior mean from MCMC:", mean(p), "\n")
cat("Posterior sd from MCMC:", sd(p), "\n")
library(rstan)
library(bayesplot)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Globe tossing data
W <- 6      # Number of water outcomes
L <- 3      # Number of land outcomes
N <- W + L  # Total tosses
# Prepare data list for Stan
data_list <- list(
N = N,
W = W
)
# Stan model as a string (could also save as .stan file)
stan_code <- "
data {
int<lower=0> N;     // total tosses
int<lower=0> W;     // number of water outcomes
}
parameters {
real<lower=0, upper=1> p;  // probability of water
}
model {
// Prior
p ~ beta(1,1);
// Likelihood
W ~ binomial(N, p);
}
"
# Compile Stan model
globe_model <- stan_model(model_code = stan_code)
# HMC sampling
set.seed(123)  # For reproducibility
fit <- sampling(
globe_model,
data = data_list,
iter = 4000,       # total iterations per chain
warmup = 1000,     # warmup / burn-in
chains = 4,        # number of chains
seed = 123
)
# Print summary
print(fit, probs = c(0.025, 0.5, 0.975))
posterior_samples <- extract(fit)$p
posterior_samples <- extract(fit)$p
# Base R density plot
plot(density(posterior_samples), xlim = c(0,1),
main = "Posterior Distribution of p (Water Probability)",
xlab = "p", ylab = "Density")
# Overlay analytical Beta posterior
curve(dbeta(x, W+1, L+1), lty = 2, add = TRUE, col = "red")
# Add legend
legend("topright", legend = c("HMC Posterior", "Analytical Beta"),
lty = c(1,2), col = c("black","red"))
# Traceplot for p
rstan::stan_trace(fit, pars = "p", inc_warmup = FALSE)
# Pairplot (not very meaningful for 1D, but following professor style)
mcmc_pairs(as.array(fit), pars = "p")
# Traceplot for p
rstan::stan_trace(fit, pars = "p", inc_warmup = FALSE)
cat("Posterior mean:", mean(posterior_samples), "\n")
cat("Posterior SD:", sd(posterior_samples), "\n")
cat("95% Credible Interval:", quantile(posterior_samples, c(0.025, 0.975)), "\n")
library(rstan)
library(bayesplot)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Globe tossing data
W <- 6      # Number of water outcomes
L <- 3      # Number of land outcomes
N <- W + L  # Total tosses
# Prepare data list for Stan
data_list <- list(
N = N,
W = W
)
# Stan model as a string (could also save as .stan file)
stan_code <- "
data {
int<lower=0> N;     // total tosses
int<lower=0> W;     // number of water outcomes
}
parameters {
real<lower=0, upper=1> p;  // probability of water
}
model {
// Prior
p ~ beta(1,1);
// Likelihood
W ~ binomial(N, p);
}
"
# Compile Stan model
globe_model <- stan_model(model_code = stan_code)
# HMC sampling
set.seed(123)  # For reproducibility
fit <- sampling(
globe_model,
data = data_list,
iter = 4000,       # total iterations per chain
warmup = 1000,     # warmup / burn-in
chains = 4,        # number of chains
seed = 123
)
# Print summary
print(fit, probs = c(0.025, 0.5, 0.975))
posterior_samples <- extract(fit)$p
posterior_samples <- extract(fit)$p
# Base R density plot
plot(density(posterior_samples), xlim = c(0,1),
main = "Posterior Distribution of p (Water Probability)",
xlab = "p", ylab = "Density")
# Overlay analytical Beta posterior
curve(dbeta(x, W+1, L+1), lty = 2, add = TRUE, col = "red")
# Add legend
legend("topright", legend = c("HMC Posterior", "Analytical Beta"),
lty = c(1,2), col = c("black","red"))
# Traceplot for p
rstan::stan_trace(fit, pars = "p", inc_warmup = FALSE)
cat("Posterior mean:", mean(posterior_samples), "\n")
cat("Posterior SD:", sd(posterior_samples), "\n")
cat("95% Credible Interval:", quantile(posterior_samples, c(0.025, 0.975)), "\n")
